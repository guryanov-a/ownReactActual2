цель? 
нужно считать количество ненужных ререндеров (а лучше и время ещё)
что такое ненужные ререндеры? 
это ререндеры (и возможно вообще когда поддерево пересоздаётся) которые происходят, когда пропсы одинаковые
как понять, что пропсы одинаковые? 
пропсы можно сравнивать через элементы: новый элемент и старый (в инстансе)
ок, а где лучше проверку засунуть? 
update component наверное и через корневой компонент изменений считать общее количество ререндеров и времени
а как считать ререндеры и время?
можно в updateComponentPerf брать временные измерения
а как вообще хранить инфо об информации и ререндрах? 
наверное лучше сделать какое-то саммари по корневому элементу сколько было ненужных ререндеров вообще и сколько времени заняло, при этом по компонентам ещё отдельно считать и наверное эту инфу использовать для саммари, при этом форматирование лучше делать наверн через путь от корня к компоненту, складывая компоненты с одинаковым путём (несколько ListItem например в List, а не каждый ListItem отдельно), при этом инфо об айди не нужно в информации о выводе (нет системы дебага по нему - бесполезен, он для временных меток только).
ок, всё что нужно решили? 
Наверн можно по пути компонента ещё подсчитывать суммарно для каждого уровня компонента: а можно ли отдельно родителя рендер посчитать от детей? ну зависит от того как родитель рендериться: свои аттрибуты - наверное лучше это считать, если можно отдельно от детей, а дом если у родителя поменяется, то это приведёт к пересозданию поддерева детей его. Хм… Ну ререндер может менять как аттрибуты, так и html компонента, что может повлечь пересоздания поддерева. Ну любой триггер для апдейта наверное нужно считать - updateComponentInstance, где пропсы инстанса равны пропсам нового элемента
Какая конкретно статистика нужна?
- счётчик ненужных ререндеров для каждого компонента отдельно (без детей)
- сколько можно сэкономить по времени, если убрать ненужные ререндеры для каждого компонента отдельно (без детей)
- счётчик ненужных ререндеров для апдейта в целом (со всеми детьми)
- сколько можно сэкономить по времени, если убрать ненужные ререндеры для для апдейта в целом (со всеми детьми)
Что нужно для этих метрик?
1,2) в withComponentUpdate сравнить пропсы и если ненужный ререндер добавить в счётчик +1 и в счётчик возможных экономий времени время на дом рендер. Сохранить отдельно (вместе с инфо по апдейту?). Собирать 2 вида статистики: для каждого компонента отдельно, что можно сразу выводить в консоль и общую стату для соседних одинаковых элементов, что будет собираться по окончанию всего ререндера поддерева рутового элемента ререндера
3,4) Собрать со всего поддерева рутового элемента поддерева счётчики ненужных ререндеров и их времени, и сложить
Для общей статы нужно как-то связать все ререндеры поддерева рутового элемента ререндера с рутовым элементом, чтобы была возможность взять инфу для статы. 
Как?
либо передавать инфу вверх до рутового элемента ререндера, либо какой-то id для всего ререндера передавать между рутовым компонентом ререндера и дочерними элементами
Что лучше?
передавать вверх выглядит проще, чем держать везде айдишник, да и хранение инфы будет отдельно от компонентов, кажется. Вопрос только в том как собирать инфу и куда её класть, и как определять рутовый элемент? типа придётся айдишник рутового элемента вниз прокидывать всем? не сильно отличается от хранения данных в профайлере, а потом сбором оттуда - различие в том как это делать. Либо из функций перформанса при измерении вверх прокидывать инфу, либо складывать в профайлер по айди.
Что лучше?
Ну для прокидывания надо брать инфу для проброса из withPerformanceUpdate для апдейта компонента при реконсилиации, причём для изменения нужно собирать для поддерева только из фукнции апдейта, а если в поддереве произошло пересоздание элемента или вложенного поддерева, если лишний ререндер привёл к этому, то это тоже надо по-идее считать. Ну при хранении и сборе инфы в профайлере по айди будет так же, вопрос не про это, это далее будем думать. Хотя походу надо собирать с поддеревьев всю инфу, а не только для компонента с перерендером ненужным (без детей). Опять отвлекаюсь. Ну айдишник всё равно надо будет прокидывать - тогда наверное лучше в профайлере все данные для подсчёта вести. 
Как прокидывать вверх можно? 
Ну сейчас похожее запускает старт измерения родительских компонентов из дом элемента, который в childInstance где-то внизу поддерева после вложенных компонентов, если они есть. Можно ли что-то похожее применить? Ну мы будем считать траты времени ненужных изменений и вот это подойдёт, но ненужные ререндеры считать бы из компонента самого. Хотя данные для ненужных ререндеров всё равно надо будет считать. Но можно подсчитать сумму отдельных элементов ререндера полного из профайлера, а можно по цепи вверх передавать. Если считать сумму, то необходимо отделить время родительских ререндеров от дочерних, а то они будут складываться и будет показывать больше времени, чем на самом деле есть
Но у способа трекания отдельного времени тоже своя особенность, что пока непонятно как трекать время для перформанс метрик без дочерних элементов. Хотя если прокидывать по дереву вверх, то будет аккумулироваться время всего поддерева - не должно быть проблемой. 
Ну а рендеры то сами как считать? Что же лучше: считать рендеры только самого компонента, или лишние ререндеры всего дерева. Наверное лучше считать рендеры самого компонента т к сложно будет отделить отдельные компоненты и идеально знать какие именно компоненты делают лишние ререндеры, а не всё поддерево
Всё? Кажется, да
Не, как именно прокидывать время и лишние ререндеры? Они эти показатели должны быть связаны? и где нужно подсчитывать? Ну дом время можно брать из updateComponent и если пропсы равны, то выводить это время как время, которое можно сэкономить. Посчитывать за один рендер легко - так же как из домом, что в предыдущем предложении. Но хочется наверное лишние ререндеры самого компонента суммарно показывать за всё время ререндера поддерева изменений, где рут - элемент который триггерит изменения. Можно наверное складывать ререндеры элемента по айдишнику, а в конце по айдишнику же их и собирать. При этом надо обернуть updateComponent рутовый в хоф, которая будет собирать эту инфу и выводить. Или не, лучше по print выводить эту инфу, но в режиме реального времени выводить сражу же по завершению ререндера поддерева. Но это значит будем по 1 выводить? ну в реальном времени и так по 1 выводиться, а общую картину можно будет получить из итоговых значений ререндера

Всё? Ну пока да, кажется

Итого:
- для лишних ререндеров прокидываем время вверх под поддереву перерендера до триггера перерендера (мы это уже делаем)
- сравнивать пропсы в updateComponent и там решать лишний перерендер или нет: если да, то выводим инфу про лишний перерендер, что он у текущего компонента есть и сколько времени можно сэкономить
- счётчик лишних перерендеров в реальном времени выводиться по 1 для каждого компонента, складываем при этом уже имеющиеся перерендеры по положению компонента в дереве, (должен получиться по виду linked list)

Выглядит норм, похвали себя! Я молодец